const core = require('@actions/core');
// const core = require('./mockCore.js');
const requestHelper = require('./requestHelper.js');

function getCVEObjects() {
  const cveResultJson = JSON.parse(core.getInput('CVEResults'));
  if (!!cveResultJson['Results']
      && Array.isArray(cveResultJson['Results'])
      && !!cveResultJson['Results'][0]
      && !!cveResultJson['Results'][0]['Vulnerabilities']
      && Array.isArray(cveResultJson['Results'][0]['Vulnerabilities'])
      && cveResultJson['Results'][0]['Vulnerabilities'].length > 0) {
    return cveResultJson['Results'][0]['Vulnerabilities'].map((x) => {
      return {
        'VulnerabilityID': x['VulnerabilityID'] ?? 'unknown',
        'PkgID': x['PkgID'] ?? 'unknown',
        'PkgName': x['PkgName'] ?? 'unknown',
        'InstalledVersion': x['InstalledVersion'],
        'FixedVersion': x['FixedVersion'],
      }
    })
  }
  return [];
}

async function run() {
  for (let cve of getCVEObjects()) {
    console.log(`Processing: ${cve.VulnerabilityID}`);
    // DETERMINE IF ISSUE EXISTS
    const jql = `project = ${core.getInput('projectKey')} AND summary ~ "${cve.VulnerabilityID}"`;
    const searchCVEPath = `/rest/api/3/search?jql=${encodeURI(jql)}`;
    console.log(`Search for CVE issue: ${searchCVEPath}`);
    const searchCVEResponse = await requestHelper.getRequest(searchCVEPath);
    let cveIssueRef;
    if (searchCVEResponse?.total === 1) {
      cveIssueRef = searchCVEResponse.issues[0];
    } else if (searchCVEResponse?.total === 0) {
      // CREATE NEW ISSUE
      const bodyData = `
      {
        "fields": {
          "project": {
            "key": "${core.getInput('projectKey')}"
          },
          "issuetype": {
            "name": "Sub-task"
          },
          "parent": {
            "key": "${core.getInput('parentIssue')}"
          },
          "summary": "${cve.VulnerabilityID}",
          "components": [{"name": "${core.getInput('componentTag')}"}]
        }
      }`
      let createIssuePath = `/rest/api/3/issue`;
      console.log(`Create new CVE issue: ${createIssuePath}`);
      cveIssueRef = await requestHelper.bodyRequestWithResult(createIssuePath, bodyData, 'POST');
    } else {
      const message = `invalid number of cve issues: ${JSON.stringify(searchCVEResponse)}`;
      console.error(message);
      core.setFailed(message);
      continue;
    }

    // Get ISSUE
    const getCVEIssuePath = `/rest/api/3/issue/${cveIssueRef.id}?fields=components,status`;
    console.log(`Get existing CVE issue: ${getCVEIssuePath}`);
    const cveIssue = await requestHelper.getRequest(getCVEIssuePath);
    // UPDATE ISSUE
    let components = cveIssue.fields.components;
    if (!Array.isArray(components)) {
      components = [];
    }
    if (!components.map((x) => x.name).includes(core.getInput('componentTag'))) {
      // ADD COMPONENT TAG
      components.push({'name': core.getInput('componentTag')});
      const bodyData = `{
        "fields": {
           "components": ${JSON.stringify(components)}
          }
        }`;
      const putUpdateIssuePath = `/rest/api/3/issue/${cveIssue.id}`;
      console.log(`Added component tag to existing issue: ${putUpdateIssuePath}`);
      await requestHelper.bodyRequest(putUpdateIssuePath, bodyData, 'PUT');
    } // else { // already up to date }

    // MOVE ISSUE STATUS
    const currentIssueStatus = cveIssue.fields.status.statusCategory.name;
    const newIssueState = !!cve['FixedVersion'] && cve['FixedVersion'] !== '' ? core.getInput('activeStatus') : core.getInput('waitingStatus');
    if (currentIssueStatus !== newIssueState) {
      console.log(`Try to find Transition from ${currentIssueStatus} to ${newIssueState}`);
      let getTransitionsPath = `/rest/api/3/issue/${cveIssue.id}/transitions`;
      console.log(`Get available transitions: ${getTransitionsPath}`);
      const getIssueTransitionsRequest = await requestHelper.getRequest(getTransitionsPath);
      for (let transitions of getIssueTransitionsRequest?.transitions) {
        if (transitions.to.statusCategory.name === newIssueState) {
          const bodyData = `{"transition": {"id": ${transitions.id}}}`;
          let transitionIssuePath = `/rest/api/2/issue/${cveIssue.id}/transitions`;
          console.log(`Transition issue: ${transitionIssuePath}`);
          await requestHelper.bodyRequest(transitionIssuePath, bodyData, 'POST');
          break;
        }
      }
    }
    console.log('---');
  }
}

try {
  run();
} catch (e) {
  console.error(`Action failed unexpectedly: ${e.message}`);
  core.setFailed(e.message);
}


/*
   #############################################################
   ! sprintId can only to be set if you do not use sub issues. !
   #############################################################
    if (sprintId === undefined) {
      //GET SPRINT ID
      let getSprintPath = `/rest/agile/1.0/board/${core.getInput('boardId')}/sprint?state=active`;
      console.log(`Get sprint ID: ${getSprintPath}`);
      const sprintPathResponse = await requestHelper.getRequest(getSprintPath);
      if (!!sprintPathResponse?.values && !!sprintPathResponse.values[0]?.id) {
        sprintId = sprintPathResponse.values[0].id;
      } else {
        message = `Unable to parse response from sprint request, got: ${JSON.stringify(response)}`;
        console.error(message);
        core.setFailed(message);
        continue;
      }
    }
 */