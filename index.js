const core = require('@actions/core');
const github = require('@actions/github')
// const core = require('./mockCore.js');
// const github = require('./mockGithub.js')
const requestHelper = require('./requestHelper.js');

function getCVEObjects() {
  const cveResultJson = JSON.parse(core.getInput('CVEResults'));
  if (!!cveResultJson['Results']
      && Array.isArray(cveResultJson['Results'])
      && !!cveResultJson['Results'][0]
      && !!cveResultJson['Results'][0]['Vulnerabilities']
      && Array.isArray(cveResultJson['Results'][0]['Vulnerabilities'])
      && cveResultJson['Results'][0]['Vulnerabilities'].length > 0) {
    return cveResultJson['Results'][0]['Vulnerabilities'].map((x) => {
      return {
        'VulnerabilityID': x['VulnerabilityID'] ?? 'unknown',
        'PkgID': x['PkgID'] ?? 'unknown',
        'InstalledVersion': x['InstalledVersion'],
        'FixedVersion': x['FixedVersion'],
      }
    })
  }
  return [];
}

function createCVEIssueBody(cve) {
  return `{
    "fields": {
      "project": {
        "key": "${core.getInput('projectKey')}"
      },
      "issuetype": {
        "name": "Sub-task"
      },
      "parent": {
        "key": "${core.getInput('parentIssue')}"
      },
      "summary": "${cve.VulnerabilityID}",
      ${!!core.getInput('versionTag') ? `"versions": [{"name": "${core.getInput('versionTag')}"}],` : ""}
      "description": ${createIssueDescription(cve)}
    }
  }`;
}

function createIssueDescription(cve) {
  return `{
    "type": "doc",
    "version": 1,
    "content": [
      {
        "type": "paragraph",
        "content": [
          {
            "text": "Vulnerable package: ${cve.PkgID}",
            "type": "text"
          }
        ]
      },
      {
        "type": "bulletList",
        "content": [
          {
            "type": "listItem",
            "content": [
              {
                "type": "paragraph",
                "content": [
                  {
                    "text": "${github.context.repo.repo} - ${github.context.ref}",
                    "type": "text"
                  }
                ]
              }
            ]
          }
        ]
      }
    ]
  }`;
}

async function updateIssueDescription(cveIssue, cve) {
  let description = "";
  if(!!cveIssue["fields"]?.["description"]?.["content"] && cveIssue["fields"]["description"]["content"].length > 1) {
    let listItems = cveIssue["fields"]["description"]["content"][1]["content"];
    if (!Array.isArray(listItems)) {
      listItems = [];
    }

    if (!listItems.map((x) => x["content"][0]["content"][0]["text"]).includes(`${github.context.repo.repo} - ${github.context.ref}`)) {
      // Add version tag
      listItems.push({
        "type": "listItem",
        "content": [
          {
            "type": "paragraph",
            "content": [
              {
                "text": `${github.context.repo.repo} - ${github.context.ref}`,
                "type": "text"
              }
            ]
          }
        ]
      });
      description = JSON.stringify(cveIssue["fields"]["description"]);
    } else {
      return; //already up to date
    }
  } else {
    description = createIssueDescription(cve);
  }

  const bodyData = `{
  "fields": {
     "description": ${description}
    }
  }`;
  const putUpdateIssuePath = `/rest/api/3/issue/${cveIssue.id}`;
  console.log(`Added version tag to existing issue: ${putUpdateIssuePath}`);
  await requestHelper.bodyRequest(putUpdateIssuePath, bodyData, 'PUT');
}

async function updateIssueVersionTag(cveIssue) {
  let versions = cveIssue["fields"]["versions"];
  if (!Array.isArray(versions)) {
    versions = [];
  }

  if (!versions.map((x) => x.name).includes(core.getInput('versionTag'))) {
    // Add version tag
    versions.push({'name': core.getInput('versionTag')});
    const bodyData = `{
      "fields": {
       "versions": ${JSON.stringify(versions)}
      }
    }`;
    const putUpdateIssuePath = `/rest/api/3/issue/${cveIssue.id}`;
    console.log(`Added version tag to existing issue: ${putUpdateIssuePath}`);
    await requestHelper.bodyRequest(putUpdateIssuePath, bodyData, 'PUT');
  } // else { // already up to date }
}

async function updateIssueStatus(cveIssue, cve) {
  const currentIssueStatus = cveIssue.fields.status.statusCategory.name;
  const newIssueState = !!cve['FixedVersion'] && cve['FixedVersion'] !== '' ? core.getInput('activeStatus') : core.getInput('waitingStatus');
  if (currentIssueStatus !== newIssueState) {
    console.log(`Try to find Transition from ${currentIssueStatus} to ${newIssueState}`);
    let getTransitionsPath = `/rest/api/3/issue/${cveIssue.id}/transitions`;
    console.log(`Get available transitions: ${getTransitionsPath}`);
    const getIssueTransitionsRequest = await requestHelper.getRequest(getTransitionsPath);
    for (let transitions of getIssueTransitionsRequest?.transitions) {
      if (transitions.to.statusCategory.name === newIssueState) {
        const bodyData = `{"transition": {"id": ${transitions.id}}}`;
        let transitionIssuePath = `/rest/api/2/issue/${cveIssue.id}/transitions`;
        console.log(`Transition issue: ${transitionIssuePath}`);
        await requestHelper.bodyRequest(transitionIssuePath, bodyData, 'POST');
        break;
      }
    }
  }
}

async function run() {
  for (let cve of getCVEObjects()) {
    console.log(`Processing: ${cve.VulnerabilityID}`);
    // determine if issue for cve already exists
    const jql = `project = ${core.getInput('projectKey')} AND summary ~ "${cve.VulnerabilityID}"`;
    const searchCVEPath = `/rest/api/3/search?jql=${encodeURI(jql)}`;
    console.log(`Search for CVE issue: ${searchCVEPath}`);
    const searchCVEResponse = await requestHelper.getRequest(searchCVEPath);
    let cveIssueRef;
    if (searchCVEResponse?.total === 1) {
      // get CVE ref
      cveIssueRef = searchCVEResponse.issues[0];
    } else if (searchCVEResponse?.total === 0) {
      // Create NEW issue
      let createIssuePath = `/rest/api/3/issue`;
      console.log(`Create new CVE issue: ${createIssuePath}`);
      cveIssueRef = await requestHelper.bodyRequestWithResult(createIssuePath, createCVEIssueBody(cve), 'POST');
    } else {
      // Error
      const message = `invalid number of cve issues: ${JSON.stringify(searchCVEResponse)}`;
      console.error(message);
      core.setFailed(message);
      continue;
    }

    // Get issue
    const getCVEIssuePath = `/rest/api/3/issue/${cveIssueRef.id}?fields=versions,status,description`;
    console.log(`Get existing CVE issue: ${getCVEIssuePath}`);
    const cveIssue = await requestHelper.getRequest(getCVEIssuePath);

    // Update issue description
    await updateIssueDescription(cveIssue, cve);

    // Update issue version (optional)
    if (core.getInput('versionTag')) {
      await updateIssueVersionTag(cveIssue);
    }
    // Update issue status (optional)
    if (core.getInput('activeStatus') && core.getInput('waitingStatus')) {
      await updateIssueStatus(cveIssue, cve);
    }

    console.log('---'); // next cve log separator
  }
}

try {
  // Execute main function asynchronous
  run();
} catch (e) {
  console.error(`Action failed unexpectedly: ${e.message}`);
  core.setFailed(e.message);
}


/*
   #############################################################
   ! sprintId can only to be set if you do not use sub issues. !
   #############################################################
    if (sprintId === undefined) {
      //GET SPRINT ID
      let getSprintPath = `/rest/agile/1.0/board/${core.getInput('boardId')}/sprint?state=active`;
      console.log(`Get sprint ID: ${getSprintPath}`);
      const sprintPathResponse = await requestHelper.getRequest(getSprintPath);
      if (!!sprintPathResponse?.values && !!sprintPathResponse.values[0]?.id) {
        sprintId = sprintPathResponse.values[0].id;
      } else {
        message = `Unable to parse response from sprint request, got: ${JSON.stringify(response)}`;
        console.error(message);
        core.setFailed(message);
        continue;
      }
    }
 */